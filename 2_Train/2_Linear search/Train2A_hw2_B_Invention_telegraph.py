""" Описание задачи:
Петя нашел на чердаке старый телеграфный аппарат и приделал к нему хитроумное устройство,
которое может печатать на телеграфной ленте определенное слово (обозначим его X).
Петино устройство может напечатать на ленте это слово сколько угодно раз.
Петя может заставить аппарат напечатать на ленте и любое другое сообщение,
но для этого ему нужно разобрать свое хитроумное устройство, и после этого он уже
не сможет печатать сообщение X. А самое главное, что напечатать даже один символ
другого сообщения потребует от Пети больше усилий, чем напечатать на ленте слово X
с помощью хитроумного устройства.

Петя хочет сделать так, чтобы всем казалось, что ему по телеграфу пришло сообщение Z.
Для этого он может (строго в этой последовательности):
- сколько угодно раз напечатать сообщение X
- разобрать хитроумное устройство и посимвольно напечатать еще что-нибудь (назовем это Y)
- оторвать и выбросить начало ленты так, чтобы на оставшейся ленте было напечатано
в точности сообщение Z
Поскольку набирать отдельные символы сообщения Y довольно сложно, Петя хочет,
чтобы в сообщении Y было как можно меньше символов.
Для лучшего понимания задачи смотрите примеры и пояснения к ним.

Формат ввода:
В первой строке вводится слово X, которое Петя может печатать с помощью хитроумного
устройства сколько угодно раз. Во второй строке вводится сообщение Z, которое хочет получить Петя.
Каждое сообщение состоит только из маленьких латинских букв и имеет длину не более 100 символов.

Формат вывода:
Выведите минимальное по длине сообщение Y, которое Пете придется допечатать вручную.
"""


def invention(x: str, z: str) -> str:
    """
    Функция invention выводит сообщение Y, которое Пете придется допечатать вручную

    Example :
     :>>> invention(mama, amamam) -> m
    1. Сначала Петя два раза напечатает слово mama, потом к нему припечатает букву m,
    а затем отрежет и выбросит три начальных символа (mam).
    Ответом является допечатываемая отдельно буква m.

     :>>> invention(ura, mura) -> mura
    2. Казалось бы, Пете стоит сначала напечатать букву m, а затем слово ura,
    которое он умеет печатать. Однако для того, чтобы напечатать m, ему придется
    разобрать свое устройство, и печатать ura ему придется также посимвольно.

     :>>> invention(computer, comp) -> comp
    3. Казалось бы, Петя может напечатать слово computer, а затем отрезать и выбросить
    его конец — однако он не может так поступить, потому что отрезать и выбросить он
    может только начало ленты.

     :>>> invention(ejudge, judge) ->
    4. Пете достаточно один раз напечатать слово ejudge, а затем отрезать и выбросить букву e.
    Ничего посимвольно выводить ему не придется, поэтому ответом является пустая строка.

     :>>> invention(m, mmm) ->
    5. Достаточно трижды напечатать исходное слово и нужный результат будет получен.
    Ничего добавлять не надо, поэтому ответ – пустая строка

    :param x: слово, которое Петя может печатать
    :param z: слово, которое Петя хочет получить
    :return: сообщение Y, которое Пете придется допечатать вручную
    """
    i = len(x) - 1
    z_rev = z[::-1]
    slovo = True
    part_slovo = True
    j = len(z) - z_rev.find(x[-1]) - 1
    y = z[j + 1:]
    if z_rev.find(x[i]) == -1:
        slovo = False
        part_slovo = False
        y = z
    # print(slovo,part_slovo,'i=',i,'j=',j,y,len(z),z_rev.find(x[-1]))
    # i-=1
    # j-=1
    while slovo and (part_slovo and j >= 0):
        # print(slovo,part_slovo,'i=',i,x[i],'j=',j,z[j],y)
        if i == -1:
            if x[-1] == z[j]:
                i = len(x) - 1
            else:
                part_slovo = False
                j_false = j
            if x.count(z[j]) == 0:
                slovo = False
                y = z
        if x[i] == z[j]:
            i -= 1
            j -= 1
            part_slovo = True
        else:
            part_slovo = False
            j_false = j
        # print(part_slovo)
        if not part_slovo:  # and x[-1]==z[j_false]:
            # print(slovo,'j_false=',j_false)
            i = len(x) - 1
            z_rev = z[:j_false]
            z_rev = z_rev[::-1]
            # print(z_rev,len(z_rev),z_rev.find(x[i]),len(z_rev)-z_rev.find(x[i])-1)
            part_slovo = True
            j = len(z_rev) - z_rev.find(x[-1]) - 1
            y = z[j + 1:]
            if z_rev.find(x[i]) == -1:
                slovo = False
                y = z
    return y


x_input = input()
z_input = input()
print(invention(x_input, z_input))
